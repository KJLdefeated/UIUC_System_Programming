/**
 * shell
 * CS 341 - Fall 2024
 */
#include "format.h"
#include "shell.h"
#include "vector.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include <dirent.h>
#include <fcntl.h>

#define MAX_PATH 1024
#define MAX_COMMAND 1024

typedef struct process {
    char *command;
    pid_t pid;
} process;

// Store process in history
void store_process(process *history, int *h_size, char *command, pid_t pid){
    history[*h_size].command = malloc(MAX_COMMAND);
    strcpy(history[*h_size].command, command);
    history[*h_size].pid = pid;
    (*h_size)++;
}

// Modify pid of entries in history
void modify_pid(process *history, int h_size, char *command, pid_t pid){
    for(int i=0;i<h_size;i++){
        if (strcmp(history[i].command, command) == 0) {
            history[i].pid = pid;
            break;
        }
    }
}

void sigint_handler(int signum) {
    // Do nothing
    //fflush(stdout);
}

void setup_signal_handlers() {
    struct sigaction sa;
    sa.sa_handler = sigint_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;  // Restart system calls if interrupted by handler
    
    if (sigaction(SIGINT, &sa, NULL) == -1) {
        perror("sigaction");
        exit(1);
    }
}

void reset_signal_handling() {
    signal(SIGINT, SIG_DFL);
}

long long get_boot_time() {
    FILE *stat_file = fopen("/proc/stat", "r");
    if (!stat_file) return 0;

    char line[256];
    long long boot_time = 0;
    while (fgets(line, sizeof(line), stat_file)) {
        if (sscanf(line, "btime %lld", &boot_time) == 1) {
            break;
        }
    }
    fclose(stat_file);
    return boot_time;
}

void get_process_info(int pid, process_info *info) {
    char path[MAX_PATH];
    FILE *file;
    long long boot_time = get_boot_time();

    info->pid = pid;

    // Get basic process info
    snprintf(path, sizeof(path), "/proc/%d/stat", pid);
    file = fopen(path, "r");
    if (file) {
        unsigned long long starttime;
        unsigned long utime, stime;
        fscanf(file, "%*d %*s %c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u %lu %lu %*d %*d %*d %*d %ld %*d %llu",
               &info->state, &utime, &stime, &info->nthreads, &starttime);
        time_t start_time = boot_time + starttime / sysconf(_SC_CLK_TCK);
        info->start_str = malloc(6);  // HH:MM\0
        time_struct_to_string(info->start_str, 6, localtime(&start_time));
        
        long long cpu_time = (utime + stime) / sysconf(_SC_CLK_TCK);
        info->time_str = malloc(10);  // MM:SS\0
        if (info->time_str) {
            snprintf(info->time_str, 10, "%lld:%02lld", cpu_time / 60, cpu_time % 60);
        }
        fclose(file);
    }

    // Get VSZ
    snprintf(path, sizeof(path), "/proc/%d/statm", pid);
    file = fopen(path, "r");
    if (file) {
        fscanf(file, "%lu", &info->vsize);
        info->vsize *= (sysconf(_SC_PAGESIZE) / 1024); // Convert to KB
        fclose(file);
    }

    // Get command
    snprintf(path, sizeof(path), "/proc/%d/cmdline", pid);
    file = fopen(path, "r");
    if (file) {
        info->command = malloc(MAX_COMMAND);
        if (info->command) {
            size_t len = fread(info->command, 1, MAX_COMMAND - 1, file);
            if (len > 0) {
                info->command[len] = '\0';
                for (size_t i = 0; i < len; i++) {
                    if (info->command[i] == '\0') info->command[i] = ' ';
                }
                info->command[len - 1] = '\0'; // Remove trailing space
            }
        }
        fclose(file);
    }
}

void free_process_info(process_info *info) {
    free(info->start_str);
    free(info->time_str);
    free(info->command);
}

void ps_command(pid_t shell_pid){
    // This is generated by copilot
    DIR *proc_dir;
    struct dirent *entry;
    process_info shell_info, child_info;

    print_process_info_header();

    // Get shell process info
    get_process_info(shell_pid, &shell_info);
    print_process_info(&shell_info);

    proc_dir = opendir("/proc");
    if(proc_dir){
        while((entry = readdir(proc_dir)) != NULL){
            pid_t pid = atoi(entry->d_name);
            if(pid > 0){
                char path[MAX_PATH];
                snprintf(path, sizeof(path), "/proc/%d/status", pid);
                FILE *file = fopen(path, "r");
                if(file){
                    char *line = NULL;
                    size_t len = 0;
                    while(getline(&line, &len, file) != -1){
                        if (strncmp(line, "PPid:", 5) == 0) {
                            pid_t ppid = atoi(line + 5);
                            if (ppid == shell_pid && pid != shell_pid) {
                                get_process_info(pid, &child_info);
                                print_process_info(&child_info);
                            }
                            break;
                        }
                    }
                    fclose(file);
                }
            }
        }
    }
}

char* find_command(pid_t pid){
    // Find the command for the given pid
    char *command = (char*)malloc(100);
    char path[MAX_PATH];
    snprintf(path, sizeof(path), "/proc/%d/cmdline", pid);
    FILE *file = fopen(path, "r");
    if (file) {
        size_t len = fread(command, 1, 100, file);
        if (len > 0) {
            command[len] = '\0';
            for (size_t i = 0; i < len; i++) {
                if (command[i] == '\0') command[i] = ' ';
            }
            command[len - 1] = '\0'; // Remove trailing space
        }
        fclose(file);
    }
    else{
        return NULL;
    }
    return command;
}

pid_t external_run(char** words, int zombie){
    pid_t pid;
    if (zombie){
		pid = fork();
		if (pid < 0){
			print_fork_failed();
			exit(-1);
		}
		else if (pid == 0){
			setpgid(0, 0);
            if(execvp(words[0], words) == -1){
                print_exec_failed(words[0]);
                exit(1);
            }
            exit(0);
		}
		else{
			print_command_executed(pid);

            // int status;
            // if (waitpid(pid, &status, WUNTRACED) == -1) {
            //     print_wait_failed();
            // }
            // if (WEXITSTATUS(status)) {
            //     return -1;
            // }
		}

	}
	else {
		pid = fork();
		if (pid < 0){
			print_fork_failed();
			exit(-1);
		}
		else if (pid == 0){
            // Both foreground and background processes should be in their own process group
            // if (setpgid(0, 0) < 0) {
            //     perror("setpgid");
            //     exit(1);
            // }
            
            reset_signal_handling();
			if(execvp(words[0], words) == -1){
                print_exec_failed(words[0]);
                exit(1);
            }
			exit(0);
		}
		else{
            // setpgid(pid, pid);
            // if (!tcsetpgrp(STDIN_FILENO, pid)) {
            //     perror("tcsetpgrp failed");
            // }

            print_command_executed(pid);

            int status;
            if (waitpid(pid, &status, WUNTRACED) == -1) {
                print_wait_failed();
            }
            if (WEXITSTATUS(status)) {
                return -1;
            }
            // if (!tcsetpgrp(STDIN_FILENO, getpid())) {
            //     perror("tcsetpgrp failed");
            // }
		}
	}
    return pid;
}

pid_t redirect(char **words, char *file, int mode){
	pid_t pid;
    pid = fork();
    if(pid < 0){
        fprintf(stderr, "fork failed");
		exit(-1);
	}
	else if(pid == 0) {
        int file_open;
        if (mode == 4) {
            file_open = open(file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
            if (file_open == -1) {
                print_redirection_file_error();
                exit(1);
            }
        }
        else if (mode == 5) {
            file_open = open(file, O_RDONLY);
            if (file_open == -1) {
                print_redirection_file_error();
                exit(1);
            }
        }
        else {
            file_open = open(file, O_WRONLY | O_CREAT | O_APPEND, 0644);
            if (file_open == -1) {
                print_redirection_file_error();
                exit(1);
            }
        }
        
        dup2(file_open, (mode == 5 ? STDIN_FILENO : STDOUT_FILENO));
        execvp(words[0], words);
        exit(1);
    }
	else {
		wait(NULL);
	}
    return pid;
}

pid_t run_cmd(char** words, int zombie){
    if(strcmp(words[0], "cd") == 0) {
        if(words[1] == NULL) {
            print_invalid_command(words[0]);
            return -1;
        }
        if(chdir(words[1]) != 0) {
            print_no_directory(words[1]);
            return -1;
        }
        return 0;
    }
    // Handle ps
    else if(strcmp(words[0], "ps") == 0){
        ps_command(getpid());
        return 0;
    } 
    // External commands
    else{
        pid_t pid = 0;
        pid = external_run(words, zombie);
        if(pid == -1) return -1;
        return pid;
    }
}

int run(char *input, process *history, int *h_size){
    // Parse the input
    char **words = malloc(30 * sizeof(char*));
	char **words1 = malloc(30 * sizeof(char*));
	for(int i=0;i<30;i++) {words[i] = malloc(50);words1[i] = malloc(50);}
    // String split
    char *input1 = strcpy(malloc(strlen(input) + 1), input);
    if (input[strlen(input)-1] == '\n')
        input[strlen(input)-1] = '\0';
    char *word = strtok(input1, " \n");
    int n = 0, m = 0, zombie = 0, mode = 0;
    while(word != NULL){
        if(word[strlen(word)-1] == ';') {
            word[strlen(word)-1] = '\0';
            mode = 1;
            words[n++] = word;
        }
        else if(!strcmp(word, "&&")) mode = 2;
        else if(!strcmp(word, "||")) mode = 3;
        else if(!strcmp(word, ">")) mode = 4;
        else if(!strcmp(word, "<")) mode = 5;
        else if(!strcmp(word, ">>")) mode = 6;
        else if(mode) words1[m++] = word;
        else words[n++] = word;
        word = strtok(NULL, " \n");
    }
    if (strcmp(words[n-1], "&") == 0){
        zombie = 1;
        n--;
    }
    words[n] = NULL;
    if(mode){
        if (strcmp(words1[m-1], "&") == 0){
            zombie = 1;
            m--;
        }
        words1[m] = NULL;
    }

    // Handle history
    if(strcmp(words[0], "!history") == 0){
        for(int i=0;i<*h_size;i++){
            print_history_line(i, history[i].command);
        }
        return 0;
    }
    // Handle history commands
    else if(words[0][0] == '#'){
        int num = atoi(words[0] + 1);
        if(num > *h_size){
            print_invalid_index();
            return -1;
        }
        print_command(history[num].command);
        run(history[num].command, history, h_size);
        return 0;
    }
    else if(words[0][0] == '!'){
        char *prefix = input + 1;
        int found = 0;
        for(int i=*h_size-1;i>=0;i--){
            int flag = 1, strlength = strlen(prefix);
            for(int j=0;j<strlength;j++){
                if(history[i].command[j] != prefix[j]){
                    flag = 0;
                    break;
                }
            }
            if(flag){
                print_command(history[i].command);
                run(history[i].command, history, h_size);
                found = 1;
                break;
            }
        }
        if(!found) print_no_history_match();
        return 0;
    }
    // Handle kill
    else if(strcmp(words[0], "kill") == 0){
        if(words[1] == NULL) {
            print_invalid_command(words[0]);
            return -1;
        }
        int pid = atoi(words[1]);
        char* cmd = find_command(pid);
        if (cmd == NULL) {
            print_no_process_found(pid);
            return -1;
        }
        if(kill(pid, SIGKILL) == -1){
            print_invalid_command(words[0]);
            return -1;
        }
        print_killed_process(pid, cmd);
        return 0;
    }
    else if(strcmp(words[0], "stop") == 0){
        if(words[1] == NULL) {
            print_invalid_command(words[0]);
            return -1;
        }
        int pid = atoi(words[1]);
        char* cmd = find_command(pid);
        if (cmd == NULL) {
            print_no_process_found(pid);
            return -1;
        }
        if(kill(pid, SIGSTOP) == -1){
            print_invalid_command(words[0]);
            return -1;
        }
        print_stopped_process(pid, cmd);
        return 0;
    }
    else if(strcmp(words[0], "cont") == 0){
        if(words[1] == NULL) {
            print_invalid_command(words[0]);
            return -1;
        }
        int pid = atoi(words[1]);
        char* cmd = find_command(pid);
        if (cmd == NULL) {
            print_no_process_found(pid);
            return -1;
        }
        if(kill(pid, SIGCONT) == -1){
            print_invalid_command(words[0]);
            return -1;
        }
        print_continued_process(pid, cmd);
        return 0;
    }
    // External commands
    else{
        pid_t pid = getpid();
        store_process(history, h_size, input, pid);
        if (mode == 0) {
            pid = run_cmd(words, zombie);
            if (pid == -1) return -1;
            modify_pid(history, *h_size, input, pid);
        }
        else if (mode == 1){
            pid = run_cmd(words, zombie);
            pid = run_cmd(words1, zombie);
            modify_pid(history, *h_size, input, pid);
        }
        else if (mode == 2) {
            if (run_cmd(words, zombie) == -1) return -1;
            if (run_cmd(words1, zombie) == -1) return -1;
            modify_pid(history, *h_size, input, pid);
        }
        else if (mode == 3) {
            if (run_cmd(words, zombie) == -1) {
                if (run_cmd(words1, zombie) == -1)
                    return -1;
            }
            modify_pid(history, *h_size, input, pid);
        }
        else if (mode == 4) {
            pid = redirect(words, words1[0], 4);
            modify_pid(history, *h_size, input, pid);
        }
        else if (mode == 5) {
            pid = redirect(words, words1[0], 5);
            modify_pid(history, *h_size, input, pid);
        }
        else if (mode == 6) {
            pid = redirect(words, words1[0], 6);
            modify_pid(history, *h_size, input, pid);
        }
    }
    return 0;
}

int shell(int argc, char *argv[]) {
    // TODO: This is the entry point for your shell.
    int h_size = 0;
    process *history = (process*)malloc(1024 * sizeof(process));
    char* history_file = (char*)malloc(100);
    char* exe_file = (char*)malloc(100);
    history_file[0] = '\0';
    exe_file[0] = '\0';

    if (argc > 5) {
        print_usage();
        return -1;
    }

    // Handle arguments
    for(int i=1;i<argc;i++){
        if(strcmp(argv[i], "-h") == 0){
            if (i + 1 < argc) {
                FILE *file = fopen(argv[i + 1], "r");
                strcpy(history_file, argv[i + 1]);
                if (file) {
                    char *line = NULL;
                    size_t len = 0;
                    while (getline(&line, &len, file) != -1) {
                        line[strlen(line) - 1] = '\0';
                        store_process(history, &h_size, line, getpid());
                    }
                    fclose(file);
                }
                // else {
                //     print_history_file_error();
                //     return -1;
                // }
                i++;
            }
            else {
                print_usage();
                return -1;
            }
        }
        if (strcmp(argv[i], "-f") == 0) {
            if (i + 1 < argc) {
                strcpy(exe_file, argv[i + 1]);
                FILE *file = fopen(argv[i + 1], "r");
                if (!file) {
                    print_script_file_error();
                    return -1;
                }
                fclose(file);
                i++;
            }
            else {
                print_usage();
                return -1;
            }
        }
    }

    setup_signal_handlers();
    
    char input[100];
    pid_t cur_pid = getpid();
    char *cur_dir = (char*)malloc(100);
    getcwd(cur_dir, 100);
    print_prompt(cur_dir, cur_pid);

    if (exe_file[0] != '\0') {
        FILE *file = fopen(exe_file, "r");
        while (fgets(input, 100, file)) {
            cur_pid = getpid();
            getcwd(cur_dir, 100);
            if(strcmp(input, "\n") == 0) {print_prompt(cur_dir, cur_pid);continue;}
            if(strcmp(input, "exit\n") == 0) break;
            run(input, history, &h_size);
            print_prompt(cur_dir, cur_pid);
        }
        fclose(file);
    }

    while(fgets(input, 100, stdin)){
        if(strcmp(input, "\n") == 0) {print_prompt(cur_dir, cur_pid);continue;}
		if(strcmp(input, "exit\n") == 0) break;
        run(input, history, &h_size);
        cur_pid = getpid();
        getcwd(cur_dir, 100);
        print_prompt(cur_dir, cur_pid);
    }

    for(int i=1;i<argc;i++){
        if(strcmp(argv[i], "-h") == 0){
            strcpy(history_file, argv[i + 1]);
            FILE *file = fopen(history_file, "w");
            for(int i=0;i<h_size;i++){
                history[i].command[strlen(history[i].command)] = '\n';
                fprintf(file, "%s", history[i].command);
            }
            fclose(file);
        }
    }

    // if (history_file[0] != '\0') {
    //     FILE *file = fopen(history_file, "w");
    //     for (int i = 0; i < h_size; i++) {
    //         history[i].command[strlen(history[i].command)] = '\n';
    //         fprintf(file, "%s", history[i].command);
    //     }
    //     fclose(file);
    // }

    // Clear zombie and free memory
    for (int i = 0; i < h_size; i++) {
        if (history[i].pid != getpid()) {
            // check if process is still running
            char path[MAX_PATH];
            snprintf(path, sizeof(path), "/proc/%d/status", history[i].pid);
            if (access(path, F_OK) != -1) {
                kill(history[i].pid, SIGKILL);
            }
        }
        free(history[i].command);
    }
    free(history);
    free(history_file);
    free(exe_file);
    free(cur_dir);

    return 0;
}
